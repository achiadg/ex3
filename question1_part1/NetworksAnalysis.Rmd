---
title: "Social Networks"
author: "Sigal Shaked"
date: "December 8, 2017"
output: html_document
---

Setting a working directory:

```{r}
folder = 'C:\\Users\\sigal\\OneDrive - post.bgu.ac.il\\sigal\\build courses\\data science\\2018\\classes\\class7'
setwd(folder)

#Or for all chuncks in this Rmarkdown:
knitr::opts_knit$set(root.dir = folder)

```

## Getting started 

1. install igraph:

```{r}
#install.packages("igraph")
#You might also need
#install.packages("digest")
#install.packages("rgl")

```

2. Google when needed: "R igraph xxx" etc.


# Working with igraph graphs

Let's take for example the following graph:

### Vertices: 

Vertices ids are always numbered from 1 to the number of nodes (Used to be numbered from 0 - not any more). 
> V = {1;2;3;4;5}

### Edges: 

An edgelist representation of the graph:
>- E = ((1;2); (1;3); (2;3); (3;5)):


Let's load this graph by passing a vector represention of the edgeIDs list and the number of nodes as parameters:

```{r}
library(igraph)
g <- graph( c(1,2,1,3,2,3,3,5), n=5 )
g
```

A (D)irected igraph object has been created, with 5 nodes and 4 edges (as displayed).


Making sure that we have an igraph object:

```{r}
class(g)
```


Summary, number of vertices, number of edges, edges, vertices:

```{r}
summary(g)
vcount(g)
ecount(g)
E(g)
V(g)
```

Is the graph directed?

```{r}
is.directed(g)
```


Convert from directed to undirected

```{r}
as.undirected(g)
```


And back
```{r}
as.directed(as.undirected(g))
```

igraph can handle multi-graphs:

```{r}
g1 <- graph( c(1,2,1,3,2,3,4,5), n=5 )
g1
```

igraph can handle loop-edges:

```{r}
g1 <- graph( c(1,1,1,3,2,3,4,5), n=5 )
g1
```

Naming vertices by setting the vertices' name attribute:

```{r}
letters = c('A','B','C','D','E')
V(g1)$name <- letters[1:5]
print(g1)

```

Plotting a graph: 

```{r}
plot(g1)
```
Now let's initialize another graph, this time using a method that creates a ring graph with the specified number of nodes.

```{r}
g <- graph.ring(10)
plot(g)
```

Now let's load a graph using an edgelist representation:

```{r}
## From edge lists
el <- cbind( c(5, 5, 1, 2),
             c(1, 2, 2, 4) )
g <- graph.edgelist(el)
g
```

We can also use named vertices in this representation:

```{r}
el <- cbind( c("Alice", "Alice", "Bob", "Cecil"),
             c("Bob", "Cecil", "Cecil", "Ed") )
g <- graph.edgelist(el)
g
```


Loading a graph using an adjacency matrix format:

```{r}
A <- matrix(sample(0:1, 100, rep=TRUE), 10, 10)
g <- graph.adjacency(A)
g
```

Loading a graph with a formula:

```{r}
## Create undirected example graph
g2 <- graph.formula(Alice-Bob:Cecil:Daniel, 
                    Cecil:Daniel-Eugene:Gordon )
g2
```

The summary output is as follows:
The first line always starts with IGRAPH, showing you that the object is an igraph graph. Then a four letter long code string is printed. The first letter distinguishes between directed ('D') and undirected ('U') graphs. The second letter is 'N' for named graphs, i.e. graphs with the name vertex attribute set. The third letter is 'W' for weighted graphs, i.e. graphs with the weight edge attribute set. The fourth letter is 'B' for bipartite graphs, i.e. for graphs with the type vertex attribute set.
Then, after two dashes, the name of the graph is printed, if it has one, i.e. if the name graph attribute is set.
From the second line, the attributes of the graph are listed, separated by a comma. After the attribute names, the kind of the attribute -- graph ('g'), vertex ('v') or edge ('e') -- is denoted, and the type of the attribute as well, character ('c'), numeric ('n'), logical ('l'), or other ('x').


## Graph Manipulate: add/delete elements

Remove alice:
```{r}
g3 <- delete.vertices(g2, 1)
g3
```

Add three new vertices
```{r}
g4 <- add.vertices(g3, 3)
g4
```

Add three new vertices, with names this time
```{r}
g4 <- add.vertices(g3, 3, attr=list(name=c("Helen", "Ike", "Jane")))
g4
```

Add some edges as well
```{r}
g4 <- add.edges(g4, c(6,7, 5,7))
g4
```

Get the id of the edge
```{r}
as.vector(E(g2, P=c(1,2)))
```

All adjacent edges of a vertex
```{r}
E(g2)[ adj(1) ]
```

Outgoing edges
```{r}
E(g2)[ from(3) ]
```

Incoming edges
```{r}
E(g2)[ to(2) ]
```

Edges along a path
```{r}
E(g2, path=c(1,4,5))
```

# Grey's Anatomy Network of Romance

Inspired by the post "Grey's Anatomy Network of Sexual Relations", by Gary Weissman. Available online at <http://www.babelgraph.org/wp/?p=1>
We will use this example to demonstrate further graph analyzing techniques and other capabilities of igraph.

Let's load the graph, this time using graph.data.frame to convert a dataframe representing an edgelist into a graph.

```{r}
ga.data <- read.csv('ga_edgelist.csv', header = T)
g <- graph.data.frame(ga.data,directed = F)
```

Check how many characters and relationships exist in the graph, and display the characters' names:
```{r}
summary(g)
V(g)$name
```


## Setting a layout

Choose a layout scheme and plot the networks (there are implementations of many layouts algorithms).

```{r}
g$layout <- layout.fruchterman.reingold(g)
plot(g)
```

```{r}
g$layout <- layout.circle(g)
plot(g)
```

```{r}
g$layout <- layout.kamada.kawai(g)
plot(g)
```


Try an interactive plot:

```{r}
tkplot(g, layout = layout.kamada.kawai)

```

## Calculate degree centrality. 

```{r}
degr.score <- degree(g)
degr.score
```

Find the vertix that has maximal degree score:

```{r}
md <- as.numeric(which(max(degr.score) == degr.score))
md
```

Delete this vertix and check how it effects the graph:

```{r}
g_<-delete.vertices(g, md)
plot(g_)
```




Plot the graph so that the size of the nodes scales with their degrees.

```{r}
V(g)$size <- degree(g) * 2 # multiply by 2 for scale 
plot(g) 
```

Remove nodes` labels.
```{r}
V(g)$label <- NA # remove labels for now 
plot(g)
```


Modify nodes' color.
For optional colors see <http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf>

```{r}
V(g)$color <- "purple"
plot(g)
```

Now let's recreate this graph, this time using additional features decribing the nodes.

```{r}
ga.data <- read.csv('ga_edgelist.csv', header=TRUE, stringsAsFactors=FALSE)
ga.vrtx <- read.csv('ga_actors.csv', header=TRUE, stringsAsFactors=FALSE)
g <- graph.data.frame(ga.data, vertices=ga.vrtx, directed=FALSE)
g
```




We assigned, in this example, a gender attribute to the actors (nodes).

```{r}
V(g)$gender
```

Let's use this attribute to color the nodes by gender:

```{r}
V(g)$size <- 7 # Set size to all nodes
V(g)$color <- "powderblue"
females <- which(V(g)$gender == "F")
V(g)$color[females] <- "pink" 
plot(g)
```

Use a different layout function:

```{r}
V(g)$label <- NA # remove labels
g$layout <- layout.kamada.kawai(g)
plot(g)
```


***

# Task 1:

1. Load Grey's Anatomy network of romances (ga_edgelist.csv).
2. Calculate degree for the various nodes, set vertix size according to its degree and plot the graph.
3. Remove the nodes with the highest and lowest degree and plot the graph again.
4. Add a new node and name it. Connect your new node to the giant component in the graph with at least 2 edges. Plot the graph again (you will need to recalculate size for the new node).
