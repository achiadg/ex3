---
title: "Clustering & Network Analysis"
author: "Sigal Shaked"
date: "December 10, 2017"
output: html_document
---

###Setups 
```{r}
folder = 'C:\\Users\\sigal\\OneDrive - post.bgu.ac.il\\sigal\\build courses\\data science\\2018\\HW\\HW3'
setwd(folder)

#Or for all chuncks in this Rmarkdown:
knitr::opts_knit$set(root.dir = folder)

```




# Community Detection in Networks (Graph Clustering)

Let's recall the graph we created in the previous lesson.

##Our Data: Grey's Anatomy Network of Romance

This is how we created and plotted the graph using the igraph package:

```{r}
#install.packages('igraph')
library(igraph)
ga.data <- read.csv('ga_edgelist.csv', header = T)
g <- graph.data.frame(ga.data,directed = F)
g$layout <- layout.fruchterman.reingold(g)
plot(g)
```


##Girvan-Newman community detection

This is a divisive method that works on undirected unweighted networks. It is based on calculating for each edge its **edge betweeness-** the number of shortest path going through this edge.

It then iteratively removes the edge with the highest betweeness score, until reaching some threshold.

The remaining connected vertices are communities (clusters).


```{r}
gc <-  edge.betweenness.community(g)
gc
```

##How to select the number of clusters?

We define a modularity measure that measures the quality of a network partition. It compares the number of edges in each cluster to the expected number of edges within it. See [wikipedia's definition](https://en.wikipedia.org/wiki/Modularity_(networks)).


```{r}
#modularity for each phase of the previous algorithm
gc$modularity
#best modularity score
max(gc$modularity)
#index (phase, i.e. partitioning) with the best score
which.max(gc$modularity)
```

Let's color nodes by partitions, using the membership function that returns community ids for each vertex, according to our clustering model object (fc).

We use the membership method to get the list of clusters assignments the nodes in the graph:
```{r}
#Store cluster ids for each vertex
memb <- membership(gc)
head(memb)
```

Then we set the node's color (vertex.color) accordingly
```{r}
plot(g, vertex.size=5, #vertex.label=NA,
     vertex.color=memb, asp=FALSE)
```

You can check other clustering algorithms, see *?igraph::communities*


***


#Task 1

1. Try other community detection algorithms, like walktrap.community, and fastgreedy.community. The last one only works on graphs with no self loops, use the function *simplify()* to omit self loops from the graph. Did you get better results? (compare modularity scores)

```{r}
#?igraph::communities
gc1 <- walktrap.community(g)
max(gc1$modularity)
```

```{r}
plot(g,  vertex.size=5, vertex.label=NA,
     vertex.color=membership(gc1), asp=FALSE)
```

```{r}
# Remove self-loops is exist
g <- simplify(g)
gc2 <-  fastgreedy.community(g)
max(gc2$modularity)
```


```{r}
plot(g,  vertex.size=5, vertex.label=NA,
     vertex.color=membership(gc2), asp=FALSE)
```

